#!/usr/bin/env python
#coding=utf-8

import StringIO
import getopt
import gzip
import socket
import struct
import sys
from collections import OrderedDict

def readline(content, idx = 0):
    if idx >= len(content):
        return -1, None
    end = content.find('\n', idx)
    if end < 0:
        end = len(content)
    return (end + 1, content[idx:end])

def getheadervalue(header):
    header = header.strip()
    idx = header.find(':')
    if idx < 0:
        return ''
    else:
        return header[idx+1:].strip()

def isGzip(content):
    """
    test if content is gzipped by magic num.
    """
    if len(content) > 3 and ord(content[0:1]) == 31 and ord(content[1:2]) == 139 and ord(content[2:3]) == 8:
        return True
    return False

def ishttprequest(body):
    idx = body.find(' ')
    if idx < 0 or idx > 10:
        return False
    method = body[0:idx].lower()
    return method in ('get', 'post', 'put', 'delete');

def ishttpresponse(body):
    return body.startswith('HTTP/') or body.startswith('http/')

def parse_content_type(content_type):
    idx = content_type.find(';')
    if idx < 0:
        idx = len(content_type)
    mime = content_type[0:idx]
    encoding = content_type[idx+1:]
    if len(encoding) > 0:
        eidx = encoding.find('=')
        if eidx > 0:
            encoding = encoding[eidx+1:]
        else:
            encoding = ''
    return (mime.strip().lower(), encoding.strip().lower())

def istextbody(mime):
    return mime.find('text') >=0 or mime.find('html')>=0 or mime.find('json')>=0 \
            or mime.find('java') >=0

def ungzip(content):
    """ungip content"""
    try:
        compresssteam = StringIO.StringIO(content)
        gzipper = gzip.GzipFile(fileobj = compresssteam)     
        content = gzipper.read()
        return content
    except:
        return content

def decode_body(content, charset):
    if charset is not None and charset != '':
        try:
            return content.decode(charset).encode('utf-8')
        except:
            return content
    else:
        # todo: encoding detect
        try:
            return content.decode('utf-8').encode('utf-8')
        except:
            pass
        try:
            return content.decode('gb18030').encode('utf-8')
        except:
            pass
        return content

def read_chunked_body(content, pos):
    """read chunked body.
    """
    result = []
    while True:
        (pos, cline) = readline(content, pos)
        if pos == -1:
            return -1, None
        chunk_size_end = cline.find(';')
        if chunk_size_end < 0:
            chunk_size_end = len(cline) 
        # skip chunk extension
        chunk_size_str = cline[0:chunk_size_end]
        # the last chunk
        if chunk_size_str[0] == '0':
            # chunk footer header
            # todo: now just skip it
            while True:
                (pos, cline) = readline(content, pos)
                if  cline is None or len(cline.strip()) == 0:
                    break
            return pos, ''.join(result)
        # chunk size
        cline = cline.strip()
        try:
            chunk_len = int(cline, 16)
        except:
            return pos, ''.join(result)

        result.append(content[pos:pos+chunk_len])
        pos += chunk_len
        if pos > len(content):
            # skip all
            pos = len(content)
            return pos, ''.join(result)
        # a CRLF to end this chunked response
        (pos, _) = readline(content, pos)

def read_request(body, pos, level, encoding):
    content_len = 0
    transfer_encoding = ''
    content_encoding = ''
    content_type = ''
    isgzip = False
    ischunked = False
    host = ''
    request = ''
    while True:
        (pos, line) = readline(body, pos);
        if pos == -1:
            return pos, None
        if level >= 1:
            print line
        lline = line.lower()
        if lline.startswith('content-length:'):
            content_len = int(getheadervalue(line))
        elif lline.startswith('transfer-encoding'):
            transfer_encoding = getheadervalue(line)
            if transfer_encoding == 'chunked':
                ischunked = True
        elif lline.startswith('content-type'):
            content_type = getheadervalue(line);
        elif lline.startswith('content-encoding'):
            content_encoding = getheadervalue(line)
            if content_encoding.find('gzip') >= 0:
                isgzip = True
        elif lline.startswith('host'):
            host = getheadervalue(line)
        elif ishttprequest(lline):
            request = line
        # end of header
        elif len(line.strip()) == 0:
            if level == 0:
                idx = request.find(' ')
                if idx >= 0 and idx < len(request) - 1:
                    request = request[0:idx+1] + host + request[idx+1:]
                idx = request.rfind(' ')
                if idx >=0:
                    request = request[0:idx]
                request = request
                print request
            break

    output_body = False
    if level >= 3:
        output_body = True
    elif level >= 2 and 'www-form-urlencoded' in content_type > 0:
        output_body = True

    content = ''
    # deal with body
    if not ischunked:
        if output_body:
            content = body[pos:pos + content_len]
        # print content
        pos += content_len
    else:
        (pos, content) = read_chunked_body(body, pos)
    
    if not isgzip:
        # if is gzip by content magic header
        # someone missed the content-encoding header
        isgzip = isGzip(content)

    if output_body and isgzip:
        content = ungzip(content)
    # if it is form url encode
    if output_body:
        print content
        print ''
    return pos, content

def read_response(body, pos, level, encoding):
    content_type = ''
    content_len = 0
    host = ''
    transfer_encoding = ''
    content_encoding = ''
    connection = ''
    isgzip = False
    ischunked = False
    while True:
        (pos, line) = readline(body, pos);
        if pos == -1:
            return pos, None
        if level >= 1:
            print line
        lline = line.lower()
        if lline.startswith('content-type'):
            content_type = getheadervalue(line)
        elif lline.startswith('content-length'):
            content_len = int(getheadervalue(line))
        elif lline.startswith('host:'):
            host = getheadervalue(line)
        elif lline.startswith('transfer-encoding'):
            transfer_encoding = getheadervalue(line)
            if transfer_encoding == 'chunked':
                ischunked = True
        elif lline.startswith('content-encoding'):
            content_encoding = getheadervalue(line)
            if 'gzip' in content_encoding:
                isgzip = True
        elif lline.startswith('connection:'):
            connection = getheadervalue(line)
        # end of header
        elif len(line.strip()) == 0:
            break

    mime, charset = parse_content_type(content_type)
    if len(encoding) > 0 and charset == '':
        charset = encoding

    output_body = False
    if level >= 3:
        output_body = True
    elif level >= 2 and istextbody(mime) > 0:
        output_body = True

    content = ''
    # deal with body
    if not ischunked:
        if content_len == 0:
            if connection == 'close':
                # we can't get content length, so asume it till the end of data.
                content_len = len(body) - pos
            else:
                # we can't get content length, and is not a chunked body.
                pass
        if output_body:
            content = body[pos : pos + content_len]
        # print content
        pos += content_len
    else:
        (pos, content) = read_chunked_body(body, pos)
    if isgzip and output_body:
        content = ungzip(content)
    # TODO: get charset from header, or cmd args
    if output_body:
        print decode_body(content, charset)
        print ''
    return pos, content

class http_conn:
    """
    all data having same source/dest ip/port.
    """

    def __init__(self, source_ip, source_port, dest_ip, dest_port, body):
        self.source_ip = source_ip
        self.source_port = source_port
        self.dest_ip = dest_ip
        self.dest_port = dest_port
        self.sio = StringIO.StringIO()
        self.sio.write(body)
    
    def append(self, another_body):
        self.sio.write(another_body)
    
    def parse(self, level, encoding):
        pos = 0
        body = self.sio.getvalue()
        self.sio.close()
        #aaa print body
        (pos_tmp, line) = readline(body, pos);
        while pos_tmp > 0:
            if ishttprequest(line):
                (pos, _) = read_request(body, pos, level, encoding)
            elif ishttpresponse(line):
                (pos, _) = read_response(body, pos, level, encoding)
            else:
                if level >= 3:
                    print "unknow:", line
                pos = pos_tmp
            (pos_tmp, line) = readline(body, pos)

def pcap_check(infile):
    """check the header of cap file.
    """

    endian = '@'
    # read 24 bytes header
    global_head = infile.read(24)
    if not global_head:
        return False, endian

    (magic_num,) = struct.unpack('<I', global_head[0:4])
    # judge the endian of file.
    if magic_num == 0xA1B2C3D4:
        endian = '<'
    elif magic_num == 0x4D3C2B1A:
        endian = '>'
    else:
        print "not pcap format."
        return False, endian
    (version_major,version_minor,timezone,timestamp,max_package_len,linklayer)  \
            = struct.unpack(endian + '4xHHIIII', global_head)

    #print "major version:", version_major
    #print "minor version:", version_minor
    #print "max packet length:", max_package_len
    #print "linklayer type:", 
    # now only handle Ethernet package.
    if linklayer == 1:
        #print "Ethernet"
        return True, endian
    elif linklayer == 6:
        print "TOKEN RING"
    elif linklayer == 10:
        print "FDDI"
    elif linklayer == 0:
        print "loop back"
    else:
        print linklayer

    return False

def check_body_empty(body):
    """检查包体是否全是0"""
    for c in body:
        if c != '\0':
            return False
    return True

def process_pcap_package(infile, endian):
    """ process one package.
        return -1 : end of file
        return 1  : invalid package
    """

    # package header
    package_header = infile.read(16)
    # end of file.
    if not package_header:
        return -1

    (seconds, suseconds, package_len, rawlen) = struct.unpack(endian + 'IIII', package_header)
    # ethernet header
    ethernet_header = infile.read(14)
    (n_protocol, ) = struct.unpack('!12xH', ethernet_header)
    # not ip package
    if n_protocol != 2048:
        return 1

    # ip header
    ip_header = infile.read(20)
    (f, ip_length, protocol) = struct.unpack('!BxH5xB10x', ip_header)
    ip_header_len = (f & 0xF) * 4;
    ip_version = (f >> 4) & 0xF
    # not tcp.
    if protocol != 6:
        return 1
    source = socket.inet_ntoa(ip_header[12:16])
    dest = socket.inet_ntoa(ip_header[16:])
    if ip_header_len > 20:
        infile.read(ip_header_len - 20)

    # tcp header
    tcp_header = infile.read(20)
    (source_port, dest_port, seq, ack, t_f, flags) = struct.unpack('!HHIIB6xB', tcp_header)
    tcp_header_len = ((t_f>>4) & 0xF) * 4
    if tcp_header_len > 20:
        infile.read(tcp_header_len - 20)
    fin = flags & 1
    syn = (flags >> 1) & 1
    rst = (flags >> 2) & 1
    psh = (flags >> 3) & 1
    ack = (flags >> 4) & 1
    urg = (flags >> 5) & 1

    # body
    body = infile.read(package_len - 14 - ip_header_len - tcp_header_len)
    # no data
    if check_body_empty(body):
        body = ''
    return (source, source_port, dest, dest_port, seconds, body)

def print_help():
    print "help"

def main():
    port = -1
    ip = ''
    show_level = 0
    encoding = ''
    opts, args = getopt.getopt(sys.argv[1:],'hvp:i:e:')
    filepath = args[0]
    for opt in opts:
        if opt[0] == '-v':
            show_level += 1
        elif opt[0] == '-h':
            print_help()
            return
        elif opt[0] == '-p':
            port = int(opt[1])
        elif opt[0] == '-i':
            ip = opt[1]
        elif opt[0] == '-e':
            encoding = opt[1]
            
    with open(filepath) as pcap_file:
        flag, endian = pcap_check(pcap_file)
        if not flag:
            # not a valid pcap file or we cannot handle this file.
            return

        conn_dict = OrderedDict()
        while True:
            result = process_pcap_package(pcap_file, endian)
            # end of file
            if result == -1:
                break
            # not handle this package
            if result == 1:
                continue
            
            (source, source_port, dest, dest_port, seconds, body) = result
            if port != -1 and source_port != port and dest_port != port:
                continue
            if ip != '' and source != ip and dest != ip:
                continue

            skey = source + ':' + str(source_port)
            dkey = dest + ':' + str(dest_port)
            if cmp(skey, dkey) < 0:
                key = skey + '-' + dkey
            else:
                key = dkey + '-' + skey
            # we already have this conn
            if key in conn_dict:
                conn_dict[key].append(body)
            # begin a new http request
            elif ishttprequest(body):
                conn_dict[key] = http_conn(source, source_port, dest, dest_port, body)
            # begin a new http response
            elif ishttpresponse(body):
                conn_dict[key] = http_conn(dest, dest_port, source, source_port, body)
            else:
                # ignore 
                pass

        for key in conn_dict:
            conn = conn_dict[key]
            print "-" * 20, conn.source_ip, ':', conn.source_port, "===>", conn.dest_ip, ':', conn.dest_port, "-" * 20
            conn.parse(show_level, encoding)
            print ''

if __name__ == "__main__":
    main()
